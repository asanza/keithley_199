/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "unity.h"
#include "cmock.h"
#include "mock_os_test.h"

typedef struct _CMOCK_xQueueCreate_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  QueueHandle_t ReturnVal;
  int CallOrder;
  int Expected_size;
  int Expected_elem_size;

} CMOCK_xQueueCreate_CALL_INSTANCE;

typedef struct _CMOCK_xQueueSend_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  void* Expected_pvItemToQueue;
  TickType_t Expected_xTicksToWait;

} CMOCK_xQueueSend_CALL_INSTANCE;

typedef struct _CMOCK_xQueuePeek_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  void* Expected_pvBuffer;
  TickType_t Expected_xTicksToWait;

} CMOCK_xQueuePeek_CALL_INSTANCE;

typedef struct _CMOCK_xQueueReceiveFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  void* Expected_pvBuffer;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;

} CMOCK_xQueueReceiveFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;

} CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xQueueSendFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  void* Expected_pvItemToQueue;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;

} CMOCK_xQueueSendFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xQueueReceive_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  void* Expected_pvBuffer;
  TickType_t Expected_xTicksToWait;

} CMOCK_xQueueReceive_CALL_INSTANCE;

typedef struct _CMOCK_xQueuePeekFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  int CallOrder;
  QueueHandle_t Expected_xQueue;
  void* Expected_pvBuffer;

} CMOCK_xQueuePeekFromISR_CALL_INSTANCE;

typedef struct _CMOCK_vTaskDelay_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  TickType_t Expected_delay;

} CMOCK_vTaskDelay_CALL_INSTANCE;

typedef struct _CMOCK_uart3_int_wrapper_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;

} CMOCK_uart3_int_wrapper_CALL_INSTANCE;

typedef struct _CMOCK_portEND_SWITCHING_ISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  portBASE_TYPE Expected_value;

} CMOCK_portEND_SWITCHING_ISR_CALL_INSTANCE;

typedef struct _CMOCK_OC3_wrapper_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;

} CMOCK_OC3_wrapper_CALL_INSTANCE;

static struct mock_os_testInstance
{
  int xQueueCreate_IgnoreBool;
  QueueHandle_t xQueueCreate_FinalReturn;
  CMOCK_xQueueCreate_CALLBACK xQueueCreate_CallbackFunctionPointer;
  int xQueueCreate_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueCreate_CallInstance;
  int xQueueSend_IgnoreBool;
  BaseType_t xQueueSend_FinalReturn;
  CMOCK_xQueueSend_CALLBACK xQueueSend_CallbackFunctionPointer;
  int xQueueSend_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueSend_CallInstance;
  int xQueuePeek_IgnoreBool;
  BaseType_t xQueuePeek_FinalReturn;
  CMOCK_xQueuePeek_CALLBACK xQueuePeek_CallbackFunctionPointer;
  int xQueuePeek_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueuePeek_CallInstance;
  int xQueueReceiveFromISR_IgnoreBool;
  BaseType_t xQueueReceiveFromISR_FinalReturn;
  CMOCK_xQueueReceiveFromISR_CALLBACK xQueueReceiveFromISR_CallbackFunctionPointer;
  int xQueueReceiveFromISR_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueReceiveFromISR_CallInstance;
  int xQueueIsQueueEmptyFromISR_IgnoreBool;
  BaseType_t xQueueIsQueueEmptyFromISR_FinalReturn;
  CMOCK_xQueueIsQueueEmptyFromISR_CALLBACK xQueueIsQueueEmptyFromISR_CallbackFunctionPointer;
  int xQueueIsQueueEmptyFromISR_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueIsQueueEmptyFromISR_CallInstance;
  int xQueueSendFromISR_IgnoreBool;
  BaseType_t xQueueSendFromISR_FinalReturn;
  CMOCK_xQueueSendFromISR_CALLBACK xQueueSendFromISR_CallbackFunctionPointer;
  int xQueueSendFromISR_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueSendFromISR_CallInstance;
  int xQueueReceive_IgnoreBool;
  BaseType_t xQueueReceive_FinalReturn;
  CMOCK_xQueueReceive_CALLBACK xQueueReceive_CallbackFunctionPointer;
  int xQueueReceive_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueueReceive_CallInstance;
  int xQueuePeekFromISR_IgnoreBool;
  BaseType_t xQueuePeekFromISR_FinalReturn;
  CMOCK_xQueuePeekFromISR_CALLBACK xQueuePeekFromISR_CallbackFunctionPointer;
  int xQueuePeekFromISR_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xQueuePeekFromISR_CallInstance;
  int vTaskDelay_IgnoreBool;
  CMOCK_vTaskDelay_CALLBACK vTaskDelay_CallbackFunctionPointer;
  int vTaskDelay_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vTaskDelay_CallInstance;
  int uart3_int_wrapper_IgnoreBool;
  CMOCK_uart3_int_wrapper_CALLBACK uart3_int_wrapper_CallbackFunctionPointer;
  int uart3_int_wrapper_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE uart3_int_wrapper_CallInstance;
  int portEND_SWITCHING_ISR_IgnoreBool;
  CMOCK_portEND_SWITCHING_ISR_CALLBACK portEND_SWITCHING_ISR_CallbackFunctionPointer;
  int portEND_SWITCHING_ISR_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE portEND_SWITCHING_ISR_CallInstance;
  int OC3_wrapper_IgnoreBool;
  CMOCK_OC3_wrapper_CALLBACK OC3_wrapper_CallbackFunctionPointer;
  int OC3_wrapper_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE OC3_wrapper_CallInstance;
} Mock;

extern jmp_buf AbortFrame;
extern int GlobalExpectCount;
extern int GlobalVerifyOrder;

void mock_os_test_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  if (Mock.xQueueCreate_IgnoreBool)
    Mock.xQueueCreate_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.xQueueCreate_CallInstance, cmock_line, "Function 'xQueueCreate' called less times than expected.");
  if (Mock.xQueueCreate_CallbackFunctionPointer != NULL)
    Mock.xQueueCreate_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.xQueueSend_IgnoreBool)
    Mock.xQueueSend_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.xQueueSend_CallInstance, cmock_line, "Function 'xQueueSend' called less times than expected.");
  if (Mock.xQueueSend_CallbackFunctionPointer != NULL)
    Mock.xQueueSend_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.xQueuePeek_IgnoreBool)
    Mock.xQueuePeek_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.xQueuePeek_CallInstance, cmock_line, "Function 'xQueuePeek' called less times than expected.");
  if (Mock.xQueuePeek_CallbackFunctionPointer != NULL)
    Mock.xQueuePeek_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.xQueueReceiveFromISR_IgnoreBool)
    Mock.xQueueReceiveFromISR_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.xQueueReceiveFromISR_CallInstance, cmock_line, "Function 'xQueueReceiveFromISR' called less times than expected.");
  if (Mock.xQueueReceiveFromISR_CallbackFunctionPointer != NULL)
    Mock.xQueueReceiveFromISR_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.xQueueIsQueueEmptyFromISR_IgnoreBool)
    Mock.xQueueIsQueueEmptyFromISR_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.xQueueIsQueueEmptyFromISR_CallInstance, cmock_line, "Function 'xQueueIsQueueEmptyFromISR' called less times than expected.");
  if (Mock.xQueueIsQueueEmptyFromISR_CallbackFunctionPointer != NULL)
    Mock.xQueueIsQueueEmptyFromISR_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.xQueueSendFromISR_IgnoreBool)
    Mock.xQueueSendFromISR_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.xQueueSendFromISR_CallInstance, cmock_line, "Function 'xQueueSendFromISR' called less times than expected.");
  if (Mock.xQueueSendFromISR_CallbackFunctionPointer != NULL)
    Mock.xQueueSendFromISR_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.xQueueReceive_IgnoreBool)
    Mock.xQueueReceive_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.xQueueReceive_CallInstance, cmock_line, "Function 'xQueueReceive' called less times than expected.");
  if (Mock.xQueueReceive_CallbackFunctionPointer != NULL)
    Mock.xQueueReceive_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.xQueuePeekFromISR_IgnoreBool)
    Mock.xQueuePeekFromISR_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.xQueuePeekFromISR_CallInstance, cmock_line, "Function 'xQueuePeekFromISR' called less times than expected.");
  if (Mock.xQueuePeekFromISR_CallbackFunctionPointer != NULL)
    Mock.xQueuePeekFromISR_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.vTaskDelay_IgnoreBool)
    Mock.vTaskDelay_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.vTaskDelay_CallInstance, cmock_line, "Function 'vTaskDelay' called less times than expected.");
  if (Mock.vTaskDelay_CallbackFunctionPointer != NULL)
    Mock.vTaskDelay_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.uart3_int_wrapper_IgnoreBool)
    Mock.uart3_int_wrapper_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.uart3_int_wrapper_CallInstance, cmock_line, "Function 'uart3_int_wrapper' called less times than expected.");
  if (Mock.uart3_int_wrapper_CallbackFunctionPointer != NULL)
    Mock.uart3_int_wrapper_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.portEND_SWITCHING_ISR_IgnoreBool)
    Mock.portEND_SWITCHING_ISR_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.portEND_SWITCHING_ISR_CallInstance, cmock_line, "Function 'portEND_SWITCHING_ISR' called less times than expected.");
  if (Mock.portEND_SWITCHING_ISR_CallbackFunctionPointer != NULL)
    Mock.portEND_SWITCHING_ISR_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.OC3_wrapper_IgnoreBool)
    Mock.OC3_wrapper_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.OC3_wrapper_CallInstance, cmock_line, "Function 'OC3_wrapper' called less times than expected.");
  if (Mock.OC3_wrapper_CallbackFunctionPointer != NULL)
    Mock.OC3_wrapper_CallInstance = CMOCK_GUTS_NONE;
}

void mock_os_test_Init(void)
{
  mock_os_test_Destroy();
}

void mock_os_test_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  Mock.xQueueCreate_CallbackFunctionPointer = NULL;
  Mock.xQueueCreate_CallbackCalls = 0;
  Mock.xQueueSend_CallbackFunctionPointer = NULL;
  Mock.xQueueSend_CallbackCalls = 0;
  Mock.xQueuePeek_CallbackFunctionPointer = NULL;
  Mock.xQueuePeek_CallbackCalls = 0;
  Mock.xQueueReceiveFromISR_CallbackFunctionPointer = NULL;
  Mock.xQueueReceiveFromISR_CallbackCalls = 0;
  Mock.xQueueIsQueueEmptyFromISR_CallbackFunctionPointer = NULL;
  Mock.xQueueIsQueueEmptyFromISR_CallbackCalls = 0;
  Mock.xQueueSendFromISR_CallbackFunctionPointer = NULL;
  Mock.xQueueSendFromISR_CallbackCalls = 0;
  Mock.xQueueReceive_CallbackFunctionPointer = NULL;
  Mock.xQueueReceive_CallbackCalls = 0;
  Mock.xQueuePeekFromISR_CallbackFunctionPointer = NULL;
  Mock.xQueuePeekFromISR_CallbackCalls = 0;
  Mock.vTaskDelay_CallbackFunctionPointer = NULL;
  Mock.vTaskDelay_CallbackCalls = 0;
  Mock.uart3_int_wrapper_CallbackFunctionPointer = NULL;
  Mock.uart3_int_wrapper_CallbackCalls = 0;
  Mock.portEND_SWITCHING_ISR_CallbackFunctionPointer = NULL;
  Mock.portEND_SWITCHING_ISR_CallbackCalls = 0;
  Mock.OC3_wrapper_CallbackFunctionPointer = NULL;
  Mock.OC3_wrapper_CallbackCalls = 0;
  GlobalExpectCount = 0;
  GlobalVerifyOrder = 0;
}

QueueHandle_t xQueueCreate(int size, int elem_size)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueCreate_CallInstance);
  Mock.xQueueCreate_CallInstance = CMock_Guts_MemNext(Mock.xQueueCreate_CallInstance);
  if (Mock.xQueueCreate_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return (QueueHandle_t)Mock.xQueueCreate_FinalReturn;
    memcpy(&Mock.xQueueCreate_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(QueueHandle_t));
    return (QueueHandle_t)cmock_call_instance->ReturnVal;
  }
  if (Mock.xQueueCreate_CallbackFunctionPointer != NULL)
  {
    return Mock.xQueueCreate_CallbackFunctionPointer(size, elem_size, Mock.xQueueCreate_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'xQueueCreate' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'xQueueCreate' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'xQueueCreate' called later than expected.");
  {
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_size, size, cmock_line, "Function 'xQueueCreate' called with unexpected value for argument 'size'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_elem_size, elem_size, cmock_line, "Function 'xQueueCreate' called with unexpected value for argument 'elem_size'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueCreate(CMOCK_xQueueCreate_CALL_INSTANCE* cmock_call_instance, int size, int elem_size)
{
  cmock_call_instance->Expected_size = size;
  cmock_call_instance->Expected_elem_size = elem_size;
}

void xQueueCreate_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreate_CALL_INSTANCE));
  CMOCK_xQueueCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreate_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreate_CallInstance, cmock_guts_index);
  Mock.xQueueCreate_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueCreate_IgnoreBool = (int)1;
}

void xQueueCreate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int size, int elem_size, QueueHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueCreate_CALL_INSTANCE));
  CMOCK_xQueueCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueCreate_CallInstance = CMock_Guts_MemChain(Mock.xQueueCreate_CallInstance, cmock_guts_index);
  Mock.xQueueCreate_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_xQueueCreate(cmock_call_instance, size, elem_size);
  memcpy(&cmock_call_instance->ReturnVal, &cmock_to_return, sizeof(QueueHandle_t));
}

void xQueueCreate_StubWithCallback(CMOCK_xQueueCreate_CALLBACK Callback)
{
  Mock.xQueueCreate_CallbackFunctionPointer = Callback;
}

BaseType_t xQueueSend(QueueHandle_t xQueue, const void* const pvItemToQueue, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueSend_CallInstance);
  Mock.xQueueSend_CallInstance = CMock_Guts_MemNext(Mock.xQueueSend_CallInstance);
  if (Mock.xQueueSend_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return (BaseType_t)Mock.xQueueSend_FinalReturn;
    memcpy(&Mock.xQueueSend_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(BaseType_t));
    return (BaseType_t)cmock_call_instance->ReturnVal;
  }
  if (Mock.xQueueSend_CallbackFunctionPointer != NULL)
  {
    return Mock.xQueueSend_CallbackFunctionPointer(xQueue, pvItemToQueue, xTicksToWait, Mock.xQueueSend_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'xQueueSend' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'xQueueSend' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'xQueueSend' called later than expected.");
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, "Function 'xQueueSend' called with unexpected value for argument 'xQueue'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_pvItemToQueue, pvItemToQueue, cmock_line, "Function 'xQueueSend' called with unexpected value for argument 'pvItemToQueue'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, "Function 'xQueueSend' called with unexpected value for argument 'xTicksToWait'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueSend(CMOCK_xQueueSend_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, const void* const pvItemToQueue, TickType_t xTicksToWait)
{
  memcpy(&cmock_call_instance->Expected_xQueue, &xQueue, sizeof(QueueHandle_t));
  cmock_call_instance->Expected_pvItemToQueue = (void*)pvItemToQueue;
  memcpy(&cmock_call_instance->Expected_xTicksToWait, &xTicksToWait, sizeof(TickType_t));
}

void xQueueSend_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueSend_CALL_INSTANCE));
  CMOCK_xQueueSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueSend_CallInstance = CMock_Guts_MemChain(Mock.xQueueSend_CallInstance, cmock_guts_index);
  Mock.xQueueSend_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueSend_IgnoreBool = (int)1;
}

void xQueueSend_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, const void* const pvItemToQueue, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueSend_CALL_INSTANCE));
  CMOCK_xQueueSend_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSend_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueSend_CallInstance = CMock_Guts_MemChain(Mock.xQueueSend_CallInstance, cmock_guts_index);
  Mock.xQueueSend_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_xQueueSend(cmock_call_instance, xQueue, pvItemToQueue, xTicksToWait);
  memcpy(&cmock_call_instance->ReturnVal, &cmock_to_return, sizeof(BaseType_t));
}

void xQueueSend_StubWithCallback(CMOCK_xQueueSend_CALLBACK Callback)
{
  Mock.xQueueSend_CallbackFunctionPointer = Callback;
}

BaseType_t xQueuePeek(QueueHandle_t xQueue, void* const pvBuffer, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueuePeek_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeek_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueuePeek_CallInstance);
  Mock.xQueuePeek_CallInstance = CMock_Guts_MemNext(Mock.xQueuePeek_CallInstance);
  if (Mock.xQueuePeek_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return (BaseType_t)Mock.xQueuePeek_FinalReturn;
    memcpy(&Mock.xQueuePeek_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(BaseType_t));
    return (BaseType_t)cmock_call_instance->ReturnVal;
  }
  if (Mock.xQueuePeek_CallbackFunctionPointer != NULL)
  {
    return Mock.xQueuePeek_CallbackFunctionPointer(xQueue, pvBuffer, xTicksToWait, Mock.xQueuePeek_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'xQueuePeek' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'xQueuePeek' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'xQueuePeek' called later than expected.");
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, "Function 'xQueuePeek' called with unexpected value for argument 'xQueue'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_pvBuffer, pvBuffer, cmock_line, "Function 'xQueuePeek' called with unexpected value for argument 'pvBuffer'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, "Function 'xQueuePeek' called with unexpected value for argument 'xTicksToWait'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueuePeek(CMOCK_xQueuePeek_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, void* const pvBuffer, TickType_t xTicksToWait)
{
  memcpy(&cmock_call_instance->Expected_xQueue, &xQueue, sizeof(QueueHandle_t));
  cmock_call_instance->Expected_pvBuffer = (void*)pvBuffer;
  memcpy(&cmock_call_instance->Expected_xTicksToWait, &xTicksToWait, sizeof(TickType_t));
}

void xQueuePeek_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueuePeek_CALL_INSTANCE));
  CMOCK_xQueuePeek_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeek_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueuePeek_CallInstance = CMock_Guts_MemChain(Mock.xQueuePeek_CallInstance, cmock_guts_index);
  Mock.xQueuePeek_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueuePeek_IgnoreBool = (int)1;
}

void xQueuePeek_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, void* const pvBuffer, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueuePeek_CALL_INSTANCE));
  CMOCK_xQueuePeek_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeek_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueuePeek_CallInstance = CMock_Guts_MemChain(Mock.xQueuePeek_CallInstance, cmock_guts_index);
  Mock.xQueuePeek_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_xQueuePeek(cmock_call_instance, xQueue, pvBuffer, xTicksToWait);
  memcpy(&cmock_call_instance->ReturnVal, &cmock_to_return, sizeof(BaseType_t));
}

void xQueuePeek_StubWithCallback(CMOCK_xQueuePeek_CALLBACK Callback)
{
  Mock.xQueuePeek_CallbackFunctionPointer = Callback;
}

BaseType_t xQueueReceiveFromISR(QueueHandle_t xQueue, void* const pvBuffer, BaseType_t* const pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueReceiveFromISR_CallInstance);
  Mock.xQueueReceiveFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueReceiveFromISR_CallInstance);
  if (Mock.xQueueReceiveFromISR_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return (BaseType_t)Mock.xQueueReceiveFromISR_FinalReturn;
    memcpy(&Mock.xQueueReceiveFromISR_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(BaseType_t));
    return (BaseType_t)cmock_call_instance->ReturnVal;
  }
  if (Mock.xQueueReceiveFromISR_CallbackFunctionPointer != NULL)
  {
    return Mock.xQueueReceiveFromISR_CallbackFunctionPointer(xQueue, pvBuffer, pxHigherPriorityTaskWoken, Mock.xQueueReceiveFromISR_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'xQueueReceiveFromISR' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'xQueueReceiveFromISR' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'xQueueReceiveFromISR' called later than expected.");
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, "Function 'xQueueReceiveFromISR' called with unexpected value for argument 'xQueue'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_pvBuffer, pvBuffer, cmock_line, "Function 'xQueueReceiveFromISR' called with unexpected value for argument 'pvBuffer'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_line, "Function 'xQueueReceiveFromISR' called with unexpected value for argument 'pxHigherPriorityTaskWoken'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueReceiveFromISR(CMOCK_xQueueReceiveFromISR_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, void* const pvBuffer, BaseType_t* const pxHigherPriorityTaskWoken)
{
  memcpy(&cmock_call_instance->Expected_xQueue, &xQueue, sizeof(QueueHandle_t));
  cmock_call_instance->Expected_pvBuffer = (void*)pvBuffer;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = (BaseType_t*)pxHigherPriorityTaskWoken;
}

void xQueueReceiveFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueReceiveFromISR_CALL_INSTANCE));
  CMOCK_xQueueReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueReceiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueReceiveFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueReceiveFromISR_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueReceiveFromISR_IgnoreBool = (int)1;
}

void xQueueReceiveFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, void* const pvBuffer, BaseType_t* const pxHigherPriorityTaskWoken, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueReceiveFromISR_CALL_INSTANCE));
  CMOCK_xQueueReceiveFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceiveFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueReceiveFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueReceiveFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueReceiveFromISR_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_xQueueReceiveFromISR(cmock_call_instance, xQueue, pvBuffer, pxHigherPriorityTaskWoken);
  memcpy(&cmock_call_instance->ReturnVal, &cmock_to_return, sizeof(BaseType_t));
}

void xQueueReceiveFromISR_StubWithCallback(CMOCK_xQueueReceiveFromISR_CALLBACK Callback)
{
  Mock.xQueueReceiveFromISR_CallbackFunctionPointer = Callback;
}

BaseType_t xQueueIsQueueEmptyFromISR(const QueueHandle_t xQueue)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueIsQueueEmptyFromISR_CallInstance);
  Mock.xQueueIsQueueEmptyFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueIsQueueEmptyFromISR_CallInstance);
  if (Mock.xQueueIsQueueEmptyFromISR_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return (BaseType_t)Mock.xQueueIsQueueEmptyFromISR_FinalReturn;
    memcpy(&Mock.xQueueIsQueueEmptyFromISR_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(BaseType_t));
    return (BaseType_t)cmock_call_instance->ReturnVal;
  }
  if (Mock.xQueueIsQueueEmptyFromISR_CallbackFunctionPointer != NULL)
  {
    return Mock.xQueueIsQueueEmptyFromISR_CallbackFunctionPointer(xQueue, Mock.xQueueIsQueueEmptyFromISR_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'xQueueIsQueueEmptyFromISR' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'xQueueIsQueueEmptyFromISR' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'xQueueIsQueueEmptyFromISR' called later than expected.");
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, "Function 'xQueueIsQueueEmptyFromISR' called with unexpected value for argument 'xQueue'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueIsQueueEmptyFromISR(CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE* cmock_call_instance, const QueueHandle_t xQueue)
{
  memcpy(&cmock_call_instance->Expected_xQueue, &xQueue, sizeof(QueueHandle_t));
}

void xQueueIsQueueEmptyFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE));
  CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueIsQueueEmptyFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueIsQueueEmptyFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueIsQueueEmptyFromISR_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueIsQueueEmptyFromISR_IgnoreBool = (int)1;
}

void xQueueIsQueueEmptyFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const QueueHandle_t xQueue, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE));
  CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueIsQueueEmptyFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueIsQueueEmptyFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueIsQueueEmptyFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueIsQueueEmptyFromISR_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_xQueueIsQueueEmptyFromISR(cmock_call_instance, xQueue);
  memcpy(&cmock_call_instance->ReturnVal, &cmock_to_return, sizeof(BaseType_t));
}

void xQueueIsQueueEmptyFromISR_StubWithCallback(CMOCK_xQueueIsQueueEmptyFromISR_CALLBACK Callback)
{
  Mock.xQueueIsQueueEmptyFromISR_CallbackFunctionPointer = Callback;
}

BaseType_t xQueueSendFromISR(QueueHandle_t xQueue, const void* const pvItemToQueue, BaseType_t* const pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueSendFromISR_CallInstance);
  Mock.xQueueSendFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueueSendFromISR_CallInstance);
  if (Mock.xQueueSendFromISR_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return (BaseType_t)Mock.xQueueSendFromISR_FinalReturn;
    memcpy(&Mock.xQueueSendFromISR_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(BaseType_t));
    return (BaseType_t)cmock_call_instance->ReturnVal;
  }
  if (Mock.xQueueSendFromISR_CallbackFunctionPointer != NULL)
  {
    return Mock.xQueueSendFromISR_CallbackFunctionPointer(xQueue, pvItemToQueue, pxHigherPriorityTaskWoken, Mock.xQueueSendFromISR_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'xQueueSendFromISR' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'xQueueSendFromISR' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'xQueueSendFromISR' called later than expected.");
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, "Function 'xQueueSendFromISR' called with unexpected value for argument 'xQueue'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_pvItemToQueue, pvItemToQueue, cmock_line, "Function 'xQueueSendFromISR' called with unexpected value for argument 'pvItemToQueue'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_line, "Function 'xQueueSendFromISR' called with unexpected value for argument 'pxHigherPriorityTaskWoken'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueSendFromISR(CMOCK_xQueueSendFromISR_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, const void* const pvItemToQueue, BaseType_t* const pxHigherPriorityTaskWoken)
{
  memcpy(&cmock_call_instance->Expected_xQueue, &xQueue, sizeof(QueueHandle_t));
  cmock_call_instance->Expected_pvItemToQueue = (void*)pvItemToQueue;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = (BaseType_t*)pxHigherPriorityTaskWoken;
}

void xQueueSendFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueSendFromISR_CALL_INSTANCE));
  CMOCK_xQueueSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueSendFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueSendFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueSendFromISR_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueSendFromISR_IgnoreBool = (int)1;
}

void xQueueSendFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, const void* const pvItemToQueue, BaseType_t* const pxHigherPriorityTaskWoken, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueSendFromISR_CALL_INSTANCE));
  CMOCK_xQueueSendFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueSendFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueSendFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueueSendFromISR_CallInstance, cmock_guts_index);
  Mock.xQueueSendFromISR_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_xQueueSendFromISR(cmock_call_instance, xQueue, pvItemToQueue, pxHigherPriorityTaskWoken);
  memcpy(&cmock_call_instance->ReturnVal, &cmock_to_return, sizeof(BaseType_t));
}

void xQueueSendFromISR_StubWithCallback(CMOCK_xQueueSendFromISR_CALLBACK Callback)
{
  Mock.xQueueSendFromISR_CallbackFunctionPointer = Callback;
}

BaseType_t xQueueReceive(QueueHandle_t xQueue, void* const pvBuffer, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueueReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueueReceive_CallInstance);
  Mock.xQueueReceive_CallInstance = CMock_Guts_MemNext(Mock.xQueueReceive_CallInstance);
  if (Mock.xQueueReceive_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return (BaseType_t)Mock.xQueueReceive_FinalReturn;
    memcpy(&Mock.xQueueReceive_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(BaseType_t));
    return (BaseType_t)cmock_call_instance->ReturnVal;
  }
  if (Mock.xQueueReceive_CallbackFunctionPointer != NULL)
  {
    return Mock.xQueueReceive_CallbackFunctionPointer(xQueue, pvBuffer, xTicksToWait, Mock.xQueueReceive_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'xQueueReceive' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'xQueueReceive' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'xQueueReceive' called later than expected.");
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, "Function 'xQueueReceive' called with unexpected value for argument 'xQueue'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_pvBuffer, pvBuffer, cmock_line, "Function 'xQueueReceive' called with unexpected value for argument 'pvBuffer'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, "Function 'xQueueReceive' called with unexpected value for argument 'xTicksToWait'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueueReceive(CMOCK_xQueueReceive_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, void* const pvBuffer, TickType_t xTicksToWait)
{
  memcpy(&cmock_call_instance->Expected_xQueue, &xQueue, sizeof(QueueHandle_t));
  cmock_call_instance->Expected_pvBuffer = (void*)pvBuffer;
  memcpy(&cmock_call_instance->Expected_xTicksToWait, &xTicksToWait, sizeof(TickType_t));
}

void xQueueReceive_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueReceive_CALL_INSTANCE));
  CMOCK_xQueueReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueReceive_CallInstance = CMock_Guts_MemChain(Mock.xQueueReceive_CallInstance, cmock_guts_index);
  Mock.xQueueReceive_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueueReceive_IgnoreBool = (int)1;
}

void xQueueReceive_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, void* const pvBuffer, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueueReceive_CALL_INSTANCE));
  CMOCK_xQueueReceive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueueReceive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueueReceive_CallInstance = CMock_Guts_MemChain(Mock.xQueueReceive_CallInstance, cmock_guts_index);
  Mock.xQueueReceive_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_xQueueReceive(cmock_call_instance, xQueue, pvBuffer, xTicksToWait);
  memcpy(&cmock_call_instance->ReturnVal, &cmock_to_return, sizeof(BaseType_t));
}

void xQueueReceive_StubWithCallback(CMOCK_xQueueReceive_CALLBACK Callback)
{
  Mock.xQueueReceive_CallbackFunctionPointer = Callback;
}

BaseType_t xQueuePeekFromISR(QueueHandle_t xQueue, void* const pvBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xQueuePeekFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeekFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xQueuePeekFromISR_CallInstance);
  Mock.xQueuePeekFromISR_CallInstance = CMock_Guts_MemNext(Mock.xQueuePeekFromISR_CallInstance);
  if (Mock.xQueuePeekFromISR_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return (BaseType_t)Mock.xQueuePeekFromISR_FinalReturn;
    memcpy(&Mock.xQueuePeekFromISR_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(BaseType_t));
    return (BaseType_t)cmock_call_instance->ReturnVal;
  }
  if (Mock.xQueuePeekFromISR_CallbackFunctionPointer != NULL)
  {
    return Mock.xQueuePeekFromISR_CallbackFunctionPointer(xQueue, pvBuffer, Mock.xQueuePeekFromISR_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'xQueuePeekFromISR' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'xQueuePeekFromISR' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'xQueuePeekFromISR' called later than expected.");
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xQueue), (void*)(&xQueue), sizeof(QueueHandle_t), cmock_line, "Function 'xQueuePeekFromISR' called with unexpected value for argument 'xQueue'.");
  }
  {
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_pvBuffer, pvBuffer, cmock_line, "Function 'xQueuePeekFromISR' called with unexpected value for argument 'pvBuffer'.");
  }
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xQueuePeekFromISR(CMOCK_xQueuePeekFromISR_CALL_INSTANCE* cmock_call_instance, QueueHandle_t xQueue, void* const pvBuffer)
{
  memcpy(&cmock_call_instance->Expected_xQueue, &xQueue, sizeof(QueueHandle_t));
  cmock_call_instance->Expected_pvBuffer = (void*)pvBuffer;
}

void xQueuePeekFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueuePeekFromISR_CALL_INSTANCE));
  CMOCK_xQueuePeekFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeekFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueuePeekFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueuePeekFromISR_CallInstance, cmock_guts_index);
  Mock.xQueuePeekFromISR_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xQueuePeekFromISR_IgnoreBool = (int)1;
}

void xQueuePeekFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, QueueHandle_t xQueue, void* const pvBuffer, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xQueuePeekFromISR_CALL_INSTANCE));
  CMOCK_xQueuePeekFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xQueuePeekFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xQueuePeekFromISR_CallInstance = CMock_Guts_MemChain(Mock.xQueuePeekFromISR_CallInstance, cmock_guts_index);
  Mock.xQueuePeekFromISR_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_xQueuePeekFromISR(cmock_call_instance, xQueue, pvBuffer);
  memcpy(&cmock_call_instance->ReturnVal, &cmock_to_return, sizeof(BaseType_t));
}

void xQueuePeekFromISR_StubWithCallback(CMOCK_xQueuePeekFromISR_CALLBACK Callback)
{
  Mock.xQueuePeekFromISR_CallbackFunctionPointer = Callback;
}

void vTaskDelay(const TickType_t delay)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTaskDelay_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTaskDelay_CallInstance);
  Mock.vTaskDelay_CallInstance = CMock_Guts_MemNext(Mock.vTaskDelay_CallInstance);
  if (Mock.vTaskDelay_IgnoreBool)
  {
    return;
  }
  if (Mock.vTaskDelay_CallbackFunctionPointer != NULL)
  {
    Mock.vTaskDelay_CallbackFunctionPointer(delay, Mock.vTaskDelay_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'vTaskDelay' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'vTaskDelay' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'vTaskDelay' called later than expected.");
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_delay), (void*)(&delay), sizeof(TickType_t), cmock_line, "Function 'vTaskDelay' called with unexpected value for argument 'delay'.");
  }
}

void CMockExpectParameters_vTaskDelay(CMOCK_vTaskDelay_CALL_INSTANCE* cmock_call_instance, const TickType_t delay)
{
  memcpy(&cmock_call_instance->Expected_delay, &delay, sizeof(TickType_t));
}

void vTaskDelay_CMockIgnore(void)
{
  Mock.vTaskDelay_IgnoreBool = (int)1;
}

void vTaskDelay_CMockExpect(UNITY_LINE_TYPE cmock_line, const TickType_t delay)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTaskDelay_CALL_INSTANCE));
  CMOCK_vTaskDelay_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTaskDelay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTaskDelay_CallInstance = CMock_Guts_MemChain(Mock.vTaskDelay_CallInstance, cmock_guts_index);
  Mock.vTaskDelay_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_vTaskDelay(cmock_call_instance, delay);
}

void vTaskDelay_StubWithCallback(CMOCK_vTaskDelay_CALLBACK Callback)
{
  Mock.vTaskDelay_CallbackFunctionPointer = Callback;
}

void uart3_int_wrapper(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uart3_int_wrapper_CALL_INSTANCE* cmock_call_instance = (CMOCK_uart3_int_wrapper_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uart3_int_wrapper_CallInstance);
  Mock.uart3_int_wrapper_CallInstance = CMock_Guts_MemNext(Mock.uart3_int_wrapper_CallInstance);
  if (Mock.uart3_int_wrapper_IgnoreBool)
  {
    return;
  }
  if (Mock.uart3_int_wrapper_CallbackFunctionPointer != NULL)
  {
    Mock.uart3_int_wrapper_CallbackFunctionPointer(Mock.uart3_int_wrapper_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'uart3_int_wrapper' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'uart3_int_wrapper' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'uart3_int_wrapper' called later than expected.");
}

void uart3_int_wrapper_CMockIgnore(void)
{
  Mock.uart3_int_wrapper_IgnoreBool = (int)1;
}

void uart3_int_wrapper_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uart3_int_wrapper_CALL_INSTANCE));
  CMOCK_uart3_int_wrapper_CALL_INSTANCE* cmock_call_instance = (CMOCK_uart3_int_wrapper_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uart3_int_wrapper_CallInstance = CMock_Guts_MemChain(Mock.uart3_int_wrapper_CallInstance, cmock_guts_index);
  Mock.uart3_int_wrapper_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
}

void uart3_int_wrapper_StubWithCallback(CMOCK_uart3_int_wrapper_CALLBACK Callback)
{
  Mock.uart3_int_wrapper_CallbackFunctionPointer = Callback;
}

void portEND_SWITCHING_ISR(portBASE_TYPE value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_portEND_SWITCHING_ISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_portEND_SWITCHING_ISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.portEND_SWITCHING_ISR_CallInstance);
  Mock.portEND_SWITCHING_ISR_CallInstance = CMock_Guts_MemNext(Mock.portEND_SWITCHING_ISR_CallInstance);
  if (Mock.portEND_SWITCHING_ISR_IgnoreBool)
  {
    return;
  }
  if (Mock.portEND_SWITCHING_ISR_CallbackFunctionPointer != NULL)
  {
    Mock.portEND_SWITCHING_ISR_CallbackFunctionPointer(value, Mock.portEND_SWITCHING_ISR_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'portEND_SWITCHING_ISR' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'portEND_SWITCHING_ISR' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'portEND_SWITCHING_ISR' called later than expected.");
  {
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_value), (void*)(&value), sizeof(portBASE_TYPE), cmock_line, "Function 'portEND_SWITCHING_ISR' called with unexpected value for argument 'value'.");
  }
}

void CMockExpectParameters_portEND_SWITCHING_ISR(CMOCK_portEND_SWITCHING_ISR_CALL_INSTANCE* cmock_call_instance, portBASE_TYPE value)
{
  memcpy(&cmock_call_instance->Expected_value, &value, sizeof(portBASE_TYPE));
}

void portEND_SWITCHING_ISR_CMockIgnore(void)
{
  Mock.portEND_SWITCHING_ISR_IgnoreBool = (int)1;
}

void portEND_SWITCHING_ISR_CMockExpect(UNITY_LINE_TYPE cmock_line, portBASE_TYPE value)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_portEND_SWITCHING_ISR_CALL_INSTANCE));
  CMOCK_portEND_SWITCHING_ISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_portEND_SWITCHING_ISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.portEND_SWITCHING_ISR_CallInstance = CMock_Guts_MemChain(Mock.portEND_SWITCHING_ISR_CallInstance, cmock_guts_index);
  Mock.portEND_SWITCHING_ISR_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_portEND_SWITCHING_ISR(cmock_call_instance, value);
}

void portEND_SWITCHING_ISR_StubWithCallback(CMOCK_portEND_SWITCHING_ISR_CALLBACK Callback)
{
  Mock.portEND_SWITCHING_ISR_CallbackFunctionPointer = Callback;
}

void OC3_wrapper(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_OC3_wrapper_CALL_INSTANCE* cmock_call_instance = (CMOCK_OC3_wrapper_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.OC3_wrapper_CallInstance);
  Mock.OC3_wrapper_CallInstance = CMock_Guts_MemNext(Mock.OC3_wrapper_CallInstance);
  if (Mock.OC3_wrapper_IgnoreBool)
  {
    return;
  }
  if (Mock.OC3_wrapper_CallbackFunctionPointer != NULL)
  {
    Mock.OC3_wrapper_CallbackFunctionPointer(Mock.OC3_wrapper_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'OC3_wrapper' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'OC3_wrapper' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'OC3_wrapper' called later than expected.");
}

void OC3_wrapper_CMockIgnore(void)
{
  Mock.OC3_wrapper_IgnoreBool = (int)1;
}

void OC3_wrapper_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_OC3_wrapper_CALL_INSTANCE));
  CMOCK_OC3_wrapper_CALL_INSTANCE* cmock_call_instance = (CMOCK_OC3_wrapper_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.OC3_wrapper_CallInstance = CMock_Guts_MemChain(Mock.OC3_wrapper_CallInstance, cmock_guts_index);
  Mock.OC3_wrapper_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
}

void OC3_wrapper_StubWithCallback(CMOCK_OC3_wrapper_CALLBACK Callback)
{
  Mock.OC3_wrapper_CallbackFunctionPointer = Callback;
}

